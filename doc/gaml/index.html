<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>gaml-1.14: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gaml-1.14
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">gaml-1.14 Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Overview"></a>
Overview</h1>
<p>The gaml library has been supported by the <a href="http://malis.metz.supelec.fr/spip.php?rubrique107">Methodeo project</a>. It consists of a C++ library, based on generic programming techniques, which offers tools for the use of machine learning: real risk estimator, manimulation of data, variable selection, etc... The library iself does not provide regression or classification algorithms, but rather allows the user to wrap around its favorite algorithms some general purpose machine learning features. Nevertheless, the famous <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/">libsvm package</a> by Chih-Chung Chang and Chih-Jen Lin has already been included in ml thanks to the <a href="http://malis.metz.supelec.fr/spip.php?article192">gaml-libsvm</a> extension.</p>
<p>Last, let us insist on one major feature of the ml lib. It relies on c++ generic programming, which is strongly typed. The design of the library fits the mathematics of machine learning concepts, and thus the strong typing forces the user to comply to those concepts. This is deliberate. The drawback is clearly that the syntax error fixing can be a hard job, since a small error in typing can generate quite a lot of error messages. In spite of this, the benefit is that all the programming effort is concentrated on that point. Indeed, when syntaxically correct, the code leads to a safe and efficient execution . Very few time is spent at debugging run time memory errors then.</p>
<h1><a class="anchor" id="The"></a>
use of iterators and functors</h1>
<p>For those who are not familiar with generic programming, the use of concept may be confusing since classical object oriented relies rather on inheritence mechanisms. A concept is a syntactical requirement. In the ml library, such requirement are documented through the use of <b>fake</b> classes in the ml::concept namespace. Let us take the exemple of the ml::concept::Predictor concept.</p>
<p>The ml::concept::Predictor concept says that some predictor must define two types, names input_type and output_type, and that it should provide some defaut and copy constructors, as well as a operator() method. Let us propose some predictor (dummy...). </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Funny {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">char</span>         input_type</div>
<div class="line">  <span class="keyword">typedef</span> std::string  output_type</div>
<div class="line"></div>
<div class="line">  Funny(<span class="keywordtype">void</span>) {}</div>
<div class="line">  Funny (<span class="keyword">const</span> Funny&amp; other) {}</div>
<div class="line">  Funny&amp; operator=(<span class="keyword">const</span> Funny&amp; other) {}</div>
<div class="line"></div>
<div class="line">  output_type operator()(<span class="keyword">const</span> input_type&amp; x)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::string(10,x); <span class="comment">// &quot;xxxxxxxxxx&quot;</span></div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This Funny class fits the ml::concept::Predictor concept while no inheritance is involved. If some algorithm in the documentation is such as it requires an argument whose type fits the ml::concept::Predictor concept, this will be specified in the documentation. For example, let us suppose that the function foo is dedicated to the manipulation of some predictor. Its declaration in the ml lib would be </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ml {</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predictor&gt;</div>
<div class="line">  <span class="keywordtype">double</span> foo(<span class="keyword">const</span> Predictor&amp; pred) {....}</div>
<div class="line">}</div>
</div><!-- fragment --><p>The use of the function in some code where Funny is available would be </p>
<div class="fragment"><div class="line">Funny funny;</div>
<div class="line"><span class="keywordtype">double</span> result = ml::foo&lt;Funny&gt;(funny);</div>
</div><!-- fragment --><p>This is will compile fine as long as the Funny class fits the ml::concept::Predictor concept. Moreover, when the compiler can guess the template parameter type from the function call, the template parameters can be removed. This leads to the following codes, that gives you the flavor of the ml function calls. </p>
<div class="fragment"><div class="line">Funny funny;</div>
<div class="line"><span class="keywordtype">double</span> result = ml::foo(funny);</div>
</div><!-- fragment --><h1><a class="anchor" id="The"></a>
use of iterators and functors</h1>
<p>This idea of the library is that data belong to collections that can be accessed by iterators. Most algorithms provided in the ml library take iterators as argument when they have to consider a collection of data. This is complient with the STL programming style. The user is thus responsible for the way s/he stores the data. Consequently s/he has to provide functions that allows to retrieve elements in each single datum in the data set. Typically, data sets contain input/output pairs. The ml algorithm will be provided with iterators on the dataset and it will acces to successive elements. From each element, the ml algoritm will have to extract the input and the output contained in the pair. In order not to impose the coding of those pairs to the user, ml algorithms will have to be given two supplementary extraction functions. Let us write some typical ml code accordingly.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span>                    Input;</div>
<div class="line"><span class="keyword">typedef</span> std::string             Output;</div>
<div class="line"><span class="keyword">typedef</span> std::pair&lt;Input,Output&gt; Data;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;Data&gt;       Samples;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> Input&amp;  input_of (<span class="keyword">const</span> Data&amp; data) {<span class="keywordflow">return</span> data.first;}</div>
<div class="line"><span class="keyword">const</span> Output&amp; output_of(<span class="keyword">const</span> Data&amp; data) {<span class="keywordflow">return</span> data.second;}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(...) {</div>
<div class="line">  Samples basis;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Let us fill the basis.</span></div>
<div class="line">  basis.resize(100);</div>
<div class="line">  <span class="keywordflow">for</span>(Samples::iterator iter = basis.begin(); iter != basis.end(); ++iter) {</div>
<div class="line">    Data&amp; data  =  *iter;</div>
<div class="line">    data.first  = <span class="comment">// init some input here</span></div>
<div class="line">    data.second = <span class="comment">// init some output here</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Let us set up a shuffled basis.</span></div>
<div class="line">  ml::Shuffle&lt;Samples::iterator,nasty-functional-types&gt; shuffled = <a class="code" href="a00187.html#ab7c3864d053ea06547b3c34eb12b9132">ml::shuffle</a>(basis.begin(),</div>
<div class="line">                                                                               basis.end());</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Let us compute something</span></div>
<div class="line">  Funny funny;</div>
<div class="line">  risk = ml::some_algo(funny,</div>
<div class="line">                       shuffled.begin(), shuffled.end(), <span class="comment">// We iterate on the shuffled basis.</span></div>
<div class="line">                       input_of,     <span class="comment">// These are the</span></div>
<div class="line">                       output_of);   <span class="comment">// extraction functions.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The previous code benefits from the template parameter implicite resolution, since ml::some_algo is a template function, whose type parameters can be ommitted, as mentioned for ml::foo previously. It can be simplified further. First, C++11 provide smarts notation for interation on collections (a new for loop syntax). Second, the auto keyword can be used where a type name is required, when the type can be guessed by the compiler. This is the case for the ml::Shuffle&lt;Samples::iterator,nasty-functional-types&gt; obscure type provided by ml. This leads to rewrite the code as this.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span>                    Input;</div>
<div class="line"><span class="keyword">typedef</span> std::string             Output;</div>
<div class="line"><span class="keyword">typedef</span> std::pair&lt;Input,Output&gt; Data;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;Data&gt;       Samples;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> Input&amp;  input_of (<span class="keyword">const</span> Data&amp; data) {<span class="keywordflow">return</span> data.first;}</div>
<div class="line"><span class="keyword">const</span> Output&amp; output_of(<span class="keyword">const</span> Data&amp; data) {<span class="keywordflow">return</span> data.second;}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(...) {</div>
<div class="line">  Samples basis;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Let us fill the basis.</span></div>
<div class="line">  basis.resize(100);</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; data : basis){</div>
<div class="line">    data.first  = <span class="comment">// init some input here</span></div>
<div class="line">    data.second = <span class="comment">// init some output here</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Let us set up a shuffled basis.</span></div>
<div class="line">  <span class="keyword">auto</span> shuffled = <a class="code" href="a00187.html#ab7c3864d053ea06547b3c34eb12b9132">ml::shuffle</a>(basis.begin(),basis.end());</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Let us compute something</span></div>
<div class="line">  Funny funny;</div>
<div class="line">  risk = ml::some_algo(funny,</div>
<div class="line">                       shuffled.begin(), shuffled.end(), </div>
<div class="line">                       input_of,</div>
<div class="line">                       output_of);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Moreover C++11 provides a syntax for the definition of functions on the fly in the code (lambda functions). This can be done for input_of and output_of. This leads to rewrite the code as this.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span>                    Input;</div>
<div class="line"><span class="keyword">typedef</span> std::string             Output;</div>
<div class="line"><span class="keyword">typedef</span> std::pair&lt;Input,Output&gt; Data;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;Data&gt;       Samples;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(...) {</div>
<div class="line">  Samples basis;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Let us fill the basis.</span></div>
<div class="line">  basis.resize(100);</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; data : basis){</div>
<div class="line">    data.first  = <span class="comment">// init some input here</span></div>
<div class="line">    data.second = <span class="comment">// init some output here</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Let us set up a shuffled basis.</span></div>
<div class="line">  <span class="keyword">auto</span> shuffled = <a class="code" href="a00187.html#ab7c3864d053ea06547b3c34eb12b9132">ml::shuffle</a>(basis.begin(),basis.end());</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Let us compute something</span></div>
<div class="line">  Funny funny;</div>
<div class="line">  risk = ml::some_algo(funny,</div>
<div class="line">                       shuffled.begin(), shuffled.end(), </div>
<div class="line">                       [](<span class="keyword">const</span> Data&amp; data) -&gt; <span class="keyword">const</span> Input&amp;  {<span class="keywordflow">return</span> data.first;},</div>
<div class="line">                       [](<span class="keyword">const</span> Data&amp; data) -&gt; <span class="keyword">const</span> Output&amp; {<span class="keywordflow">return</span> data.second;});</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="Read"></a>
the documentation</h1>
<p>The user manual of the ml library consists of a set of examples, available in this documentation. They are ordered, and they should be read in that order to get a comprehensive overview of the ml features.</p>
<h1><a class="anchor" id="Conclusion"></a>
Conclusion</h1>
<p>The use of ml implies invoking templates that can by intricated. Thanks to C++11 syntactical elements (as auto), this intrication can be hidden to the user so that the code is kept readible. The code expresses naturally the machine learning methodological concepts, and type checking ensures that they are not misused. Once compiled, as all the type checking effort is made at compiling time, the executable is safe and efficient. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
